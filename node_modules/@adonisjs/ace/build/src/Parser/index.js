"use strict";
/*
 * @adonisjs/ace
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const getopts_1 = __importDefault(require("getopts"));
const Exceptions_1 = require("../Exceptions");
/**
 * The job of the parser is to parse the command line values by taking
 * the command `args`, `flags` and `globalFlags` into account.
 */
class Parser {
    constructor(registeredFlags) {
        this.registeredFlags = registeredFlags;
    }
    /**
     * Processes ace command flag to set the options for `getopts`.
     */
    preProcessFlag(flag, options) {
        /**
         * Register alias (when exists)
         */
        if (flag.alias) {
            options.alias[flag.alias] = flag.name;
        }
        /**
         * Register flag as boolean when `flag.type === 'boolean'`
         */
        if (flag.type === 'boolean') {
            options.boolean.push(flag.name);
        }
        /**
         * Register flag as string when `flag.type === 'string' | 'array'`
         */
        if (['string', 'array'].indexOf(flag.type) > -1) {
            options.string.push(flag.name);
        }
        /**
         * Set default value when defined on the flag
         */
        if (flag.default !== undefined) {
            options.default[flag.name] = flag.default;
        }
    }
    /**
     * Casts value of a flag to it's expected data type. These values
     * are then later validated to ensure that casting was successful.
     */
    castFlag(flag, parsed) {
        const value = parsed[flag.name];
        /**
         * Return early when value is undefined or it's type is not an array
         * type
         */
        if (['boolean', 'string', 'number'].indexOf(flag.type) > -1) {
            return;
        }
        /**
         * If value is already and array then their is no point
         * of casting them to an array
         */
        if (Array.isArray(value)) {
            return;
        }
        /**
         * Parse string as array seperated by comma
         */
        if (flag.type === 'array') {
            parsed[flag.name] = value ? value.split(',') : [];
            return;
        }
        /**
         * Parse numbers as an array of numbers seperated by comma
         */
        if (flag.type === 'numArray') {
            parsed[flag.name] = value
                ? typeof value === 'string'
                    ? value.split(',').map((one) => Number(one))
                    : [Number(value)]
                : [];
        }
    }
    /**
     * Validating the flag to ensure that it's valid as per the
     * desired data type.
     */
    validateFlag(flag, parsed, command) {
        const value = parsed[flag.name];
        if (value === undefined) {
            return;
        }
        if (flag.type === 'string' && typeof value !== 'string') {
            throw Exceptions_1.InvalidFlagException.invoke(flag.name, flag.type, command);
        }
        if (flag.type === 'number' && typeof value !== 'number') {
            throw Exceptions_1.InvalidFlagException.invoke(flag.name, flag.type, command);
        }
        /**
         * Raise error when value is expected to be an array of numbers
         * but one or more values are not numbers or is NAN.
         */
        if (flag.type === 'numArray' &&
            value.findIndex((one) => {
                return typeof one !== 'number' || isNaN(one);
            }) > -1) {
            throw Exceptions_1.InvalidFlagException.invoke(flag.name, flag.type, command);
        }
    }
    /**
     * Validates the value to ensure that values are defined for
     * required arguments.
     */
    validateArg(arg, index, parsed, command) {
        const value = parsed._[index];
        if (value === undefined && arg.required) {
            throw Exceptions_1.MissingArgumentException.invoke(arg.name, command);
        }
    }
    /**
     * Parses argv and executes the command and global flags handlers
     */
    parse(argv, command) {
        let options = { alias: {}, boolean: [], default: {}, string: [] };
        const globalFlags = Object.keys(this.registeredFlags).map((name) => this.registeredFlags[name]);
        /**
         * Build options from global flags
         */
        globalFlags.forEach((flag) => this.preProcessFlag(flag, options));
        /**
         * Build options from command flags
         */
        if (command) {
            command.flags.forEach((flag) => this.preProcessFlag(flag, options));
        }
        /**
         * Parsing argv with the previously built options
         */
        const parsed = getopts_1.default(argv, options);
        /**
         * Validating global flags (if any)
         */
        globalFlags.forEach((flag) => {
            this.castFlag(flag, parsed);
            this.validateFlag(flag, parsed);
        });
        /**
         * Validating command flags (if command is defined)
         */
        if (command) {
            command.flags.forEach((flag) => {
                this.castFlag(flag, parsed);
                this.validateFlag(flag, parsed, command);
            });
        }
        return parsed;
    }
}
exports.Parser = Parser;
