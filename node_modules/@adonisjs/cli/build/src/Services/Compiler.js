"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const del_1 = __importDefault(require("del"));
const copyfiles_1 = __importDefault(require("copyfiles"));
const nanomatch_1 = __importDefault(require("nanomatch"));
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const chokidar_ts_1 = require("@poppinss/chokidar-ts");
const Installer_1 = require("./Installer");
const HttpServer_1 = require("./HttpServer");
const ioc_1 = require("../Transformers/ioc");
const logger_1 = require("./logger");
class Compiler {
    constructor(_command, _projectRoot, _rcFile, _nodeArgs) {
        this._command = _command;
        this._projectRoot = _projectRoot;
        this._rcFile = _rcFile;
        this._nodeArgs = _nodeArgs;
        this._metaFilePatterns = this._rcFile.metaFiles.map((file) => file.pattern);
        this._reloadServerPatterns = this._rcFile.metaFiles
            .filter((file) => file.reloadServer)
            .map((file) => file.pattern);
        const compilerPath = require.resolve('typescript/lib/typescript', { paths: [this._projectRoot] });
        this._compiler = new chokidar_ts_1.TypescriptCompiler(require(compilerPath), 'tsconfig.json', this._projectRoot);
        this._compiler.use((ts) => {
            return ioc_1.iocTransformer(ts, this._rcFile);
        }, 'after');
        this._ts = this._compiler['_ts'];
    }
    _clearScreen() {
        process.stdout.write('\x1B[2J\x1B[3J\x1B[H\x1Bc');
    }
    async _copyFiles(files, dest) {
        return new Promise((resolve, reject) => {
            logger_1.logPairs(this._command, [
                ['copy', ` ${files.join(',')} `],
                ['to', ` ${this._getRelativePath(dest)}`],
            ]);
            copyfiles_1.default(files.concat(dest), {}, (error) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
    async _cleanupBuildDir(outDir) {
        logger_1.logInfo(this._command, 'cleanup build', this._getRelativePath(outDir));
        await del_1.default(outDir);
        await fs_extra_1.ensureDir(outDir);
    }
    _getRelativePath(filePath) {
        return path_1.relative(this._projectRoot, filePath);
    }
    _formatDiagnostic(diagnostic) {
        const formattedText = this._ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
        let message = '';
        if (diagnostic.file) {
            const relativePath = this._getRelativePath(diagnostic.file.fileName);
            const { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
            message += this._command.colors.dim(`> ${relativePath}(${line + 1}:${character + 1}) `);
        }
        else {
            message += this._command.colors.dim('> ');
        }
        message += this._command.colors.dim(`[TS${diagnostic.code}]: `);
        message += this._command.colors.red(formattedText);
        return message;
    }
    _parseConfig() {
        const { error, config } = this._compiler.parseConfig({ declaration: false });
        if (error) {
            const header = this._command.colors.red('Typescript config parse error');
            const body = this._formatDiagnostic(error);
            logger_1.logTsCompilerError(header, body);
            return;
        }
        if (config.errors.length) {
            const header = this._command.colors.red('Typescript config parse error');
            const body = config.errors.map((error) => this._formatDiagnostic(error));
            logger_1.logTsCompilerError(header, body.join('\n'));
            return;
        }
        if (!config.options.rootDir) {
            this._command.$error('Make sure to define {rootDir} in tsconfig.json file');
            return;
        }
        config.options.outDir = config.options.outDir || 'build';
        return config;
    }
    _processBuildDiagnostics(hasError, diagnostics) {
        if (!diagnostics.length) {
            return;
        }
        const header = this._command
            .colors
            .red(`Typescript compiler error ${hasError ? '(emitSkipped)' : ''}`);
        const body = diagnostics.map((diagnostic) => this._formatDiagnostic(diagnostic));
        logger_1.logTsCompilerError(header, body.join('\n'));
    }
    async _handleFileChange(filePath, outDir, httpServer) {
        if (nanomatch_1.default.isMatch(filePath, this._reloadServerPatterns)) {
            await this._copyFiles([filePath], outDir);
            httpServer.restart();
            return;
        }
        if (nanomatch_1.default.isMatch(filePath, this._metaFilePatterns)) {
            await this._copyFiles([filePath], outDir);
        }
    }
    async _peformInitialTasks(config) {
        await this._cleanupBuildDir(config.options.outDir);
        await this._copyFiles(this._metaFilePatterns, config.options.outDir);
    }
    async build(startServer = false) {
        const config = this._parseConfig();
        if (!config) {
            return;
        }
        await this._peformInitialTasks(config);
        this._compiler.on('initial:build', (hasError, diagnostic) => {
            this._processBuildDiagnostics(hasError, diagnostic);
            if (startServer && !hasError) {
                console.log(this._command.colors.bgGreen().black(' Starting server '));
                new HttpServer_1.HttpServer(`${config.options.outDir}/server.js`, this._projectRoot, this._nodeArgs).start();
            }
        });
        this._compiler.build(config);
    }
    async buildForProduction(client) {
        const config = this._parseConfig();
        if (!config) {
            return;
        }
        await this._peformInitialTasks(config);
        this._compiler.on('initial:build', (hasError, diagnostic) => {
            this._processBuildDiagnostics(hasError, diagnostic);
            if (!hasError) {
                const helpText = `${client === 'npm' ? 'npm' : 'yarn'} install --production`;
                logger_1.logInfo(this._command, 'install dependencies', helpText);
                new Installer_1.Installer(config.options.outDir, client, true).install();
            }
        });
        this._compiler.build(config);
    }
    async watch() {
        const config = this._parseConfig();
        if (!config) {
            return;
        }
        const httpServer = new HttpServer_1.HttpServer(`${config.options.outDir}/server.js`, this._projectRoot, this._nodeArgs);
        await this._cleanupBuildDir(config.options.outDir);
        await this._copyFiles(this._metaFilePatterns, config.options.outDir);
        this._compiler.on('initial:build', (hasError, diagnostics) => {
            this._processBuildDiagnostics(hasError, diagnostics);
            if (!hasError && diagnostics.length === 0) {
                console.log(this._command.colors.bgGreen().black(' Starting server '));
                httpServer.start();
            }
        });
        this._compiler.on('subsequent:build', (filePath, hasError, diagnostics) => {
            this._clearScreen();
            this._processBuildDiagnostics(hasError, diagnostics);
            if (!hasError && diagnostics.length === 0) {
                logger_1.logInfo(this._command, 'compiled', filePath);
                httpServer.restart();
            }
        });
        this._compiler.on('add', (filePath) => {
            this._handleFileChange(filePath, config.options.outDir, httpServer);
        });
        this._compiler.on('change', (filePath) => {
            this._handleFileChange(filePath, config.options.outDir, httpServer);
        });
        this._compiler.on('unlink', async (filePath) => {
            if (nanomatch_1.default.isMatch(filePath, this._metaFilePatterns)) {
                logger_1.logInfo(this._command, 'removing', filePath);
                await fs_extra_1.remove(path_1.join(config.options.outDir, filePath));
            }
        });
        this._compiler.on('source:unlink', async (filePath) => {
            const outputPath = path_1.relative(config.options.rootDir, filePath).replace(/\.(d)?ts$/, '.js');
            logger_1.logInfo(this._command, 'removing', outputPath);
            await fs_extra_1.remove(path_1.join(config.options.outDir, outputPath));
            httpServer.restart();
        });
        const metaFiles = this._metaFilePatterns.map((file) => path_1.join(this._projectRoot, file));
        this._compiler.watch(config, ['.'], {
            ignored: [
                'node_modules/**',
                `${config.options.outDir}/**`,
                (filePath) => {
                    if (/(^|[\/\\])\../.test(filePath)) {
                        return !nanomatch_1.default.isMatch(filePath, metaFiles);
                    }
                    return false;
                },
            ],
        });
    }
}
exports.Compiler = Compiler;
