"use strict";
/*
 * @adonisjs/ace
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Kernel = void 0;
const Hooks_1 = require("../Hooks");
const Parser_1 = require("../Parser");
const HelpCommand_1 = require("../HelpCommand");
const help_1 = require("../utils/help");
const validateCommand_1 = require("../utils/validateCommand");
const InvalidCommandException_1 = require("../Exceptions/InvalidCommandException");
/**
 * Ace kernel class is used to register, find and invoke commands by
 * parsing `process.argv.splice(2)` value.
 */
class Kernel {
    constructor(application) {
        this.application = application;
        /**
         * List of registered commands
         */
        this.commands = {};
        /**
         * List of registered flags
         */
        this.flags = {};
        /**
         * Reference to hooks class to execute lifecycle
         * hooks
         */
        this.hooks = new Hooks_1.Hooks();
        /**
         * The default command that will be invoked when no command is
         * defined
         */
        this.defaultCommand = HelpCommand_1.HelpCommand;
    }
    /**
     * Executing global flag handlers. The global flag handlers are
     * not async as of now, but later we can look into making them
     * async.
     */
    executeGlobalFlagsHandlers(options, command) {
        const globalFlags = Object.keys(this.flags);
        globalFlags.forEach((name) => {
            const value = options[name];
            /**
             * Flag was not specified
             */
            if (value === undefined) {
                return;
            }
            /**
             * Flag was not specified, but `getops` will return empty array or
             * empty string, when we coerce flag to be a string or array
             */
            if ((typeof value === 'string' || Array.isArray(value)) && !value.length) {
                return;
            }
            /**
             * Calling the handler
             */
            this.flags[name].handler(options[name], options, command);
        });
    }
    /**
     * Returns an array of all registered commands
     */
    getAllCommands() {
        let commands = Object.keys(this.commands).map((name) => this.commands[name]);
        /**
         * Concat manifest commands when they exists
         */
        if (this.manifestCommands) {
            const manifestCommands = Object.keys(this.manifestCommands).map((name) => this.manifestCommands[name]);
            commands = commands.concat(manifestCommands);
        }
        return commands;
    }
    before(action, callback) {
        this.hooks.add('before', action, callback);
        return this;
    }
    after(action, callback) {
        this.hooks.add('after', action, callback);
        return this;
    }
    /**
     * Register an array of commands
     */
    register(commands) {
        commands.forEach((command) => {
            command.boot();
            validateCommand_1.validateCommand(command);
            this.commands[command.commandName] = command;
        });
        return this;
    }
    /**
     * Returns an array of command names suggestions for a given name.
     */
    getSuggestions(name, distance = 3) {
        const leven = require('leven');
        return this.getAllCommands().filter(({ commandName }) => {
            return leven(name, commandName) <= distance;
        });
    }
    /**
     * Register a global flag. It can be defined in combination with
     * any command.
     */
    flag(name, handler, options) {
        this.flags[name] = Object.assign({
            name,
            propertyName: name,
            handler,
            type: 'boolean',
        }, options);
        return this;
    }
    /**
     * Finds the command from the command line argv array. If command for
     * the given name doesn't exists, then it will return `null`.
     */
    async find(argv) {
        /**
         * ----------------------------------------------------------------------------
         * Even though in `Unix` the command name may appear in between or at last, with
         * ace we always want the command name to be the first argument. However, the
         * arguments to the command itself can appear in any sequence. For example:
         *
         * Works
         *    - node ace make:controller foo
         *    - node ace make:controller --http foo
         *
         * Doesn't work
         *    - node ace foo make:controller
         * ----------------------------------------------------------------------------
         */
        const [commandName] = argv;
        /**
         * Manifest commands gets preference over manually registered commands.
         */
        if (this.manifestCommands && this.manifestCommands[commandName]) {
            /**
             * Passing manifest node to the command
             */
            await this.hooks.excute('before', 'find', this.manifestCommands[commandName]);
            const command = this.manifest.loadCommand(this.manifestCommands[commandName].commandPath);
            /**
             * Passing actual command constructor
             */
            await this.hooks.excute('after', 'find', command.command);
            return command.command;
        }
        /**
         * Try to find command inside manually registered command or fallback
         * to null
         */
        const command = this.commands[commandName] || null;
        /**
         * Executing before and after together to be compatible
         * with the manifest find before and after hooks
         */
        await this.hooks.excute('before', 'find', command);
        await this.hooks.excute('after', 'find', command);
        return command;
    }
    /**
     * Run a given command by parsing the command line arguments
     */
    async runCommand(commandInstance, argv) {
        /**
         * The first value in the `argv` array is the command name. Now since
         * we know the command already, we remove the first value.
         */
        argv = argv.splice(1);
        const parser = new Parser_1.Parser(this.flags);
        const command = commandInstance.constructor;
        /**
         * Parse argv and execute the `handle` method.
         */
        const parsedOptions = parser.parse(argv, command);
        this.executeGlobalFlagsHandlers(parsedOptions, command);
        /**
         * We validate the command arguments after the global flags have been
         * executed. It is required, since flags may have nothing to do
         * with the validaty of command itself
         */
        command.args.forEach((arg, index) => {
            parser.validateArg(arg, index, parsedOptions, command);
        });
        /**
         * Creating a new command instance and setting
         * parsed options on it.
         */
        commandInstance.parsed = parsedOptions;
        /**
         * Setup command instance argument and flag
         * properties.
         */
        for (let i = 0; i < command.args.length; i++) {
            const arg = command.args[i];
            if (arg.type === 'spread') {
                commandInstance[arg.propertyName] = parsedOptions._.slice(i);
                break;
            }
            else {
                commandInstance[arg.propertyName] = parsedOptions._[i];
            }
        }
        /**
         * Set flag value on the command instance
         */
        command.flags.forEach((flag) => {
            const defaultValue = commandInstance[flag.propertyName];
            /*
             * For non-boolean values, we allow setting a default value on the instance property. This is
             * helpful when someone wants to use a dynamic property that shows up on the command
             * instance after instantiating the class.
             */
            if (flag.type !== 'boolean' && defaultValue !== undefined) {
                commandInstance[flag.propertyName] = parsedOptions[flag.name] || defaultValue;
            }
            else {
                commandInstance[flag.propertyName] = parsedOptions[flag.name];
            }
        });
        await this.hooks.excute('before', 'run', commandInstance);
        const response = await this.application.container.call(commandInstance, 'handle', []);
        await this.hooks.excute('after', 'run', commandInstance);
        return response;
    }
    /**
     * Running default command
     */
    async runDefaultCommand() {
        this.defaultCommand.boot();
        validateCommand_1.validateCommand(this.defaultCommand);
        const commandInstance = this.application.container.make(this.defaultCommand, [
            this.application,
            this,
        ]);
        return this.runCommand(commandInstance, []);
    }
    /**
     * Preload the manifest file. Re-running this method twice will
     * result in a noop
     */
    async preloadManifest() {
        /**
         * Load manifest commands when instance of manifest exists. From here the
         * kernel will give preference to the `manifest` file vs manually
         * registered commands.
         */
        if (this.manifest && !this.manifestCommands) {
            this.manifestCommands = await this.manifest.load();
        }
    }
    /**
     * Makes instance of a given command by processing command line arguments
     * and setting them on the command instance
     */
    async handle(argv) {
        await this.preloadManifest();
        /**
         * Execute the default command when no command is mentioned
         */
        if (!argv.length) {
            return this.runDefaultCommand();
        }
        const hasMentionedCommand = !argv[0].startsWith('-');
        /**
         * Parse flags when no command is defined
         */
        if (!hasMentionedCommand) {
            const parsedOptions = new Parser_1.Parser(this.flags).parse(argv);
            this.executeGlobalFlagsHandlers(parsedOptions);
            return;
        }
        /**
         * Execute command
         */
        return this.exec(argv[0], argv.slice(1, argv.length));
    }
    /**
     * Execute a given command. The `args` must be an array of arguments including
     * flags to be parsed and passed to the command. For exmaple:
     *
     * ```js
     * kernel.exec('make:controller', ['User', '--resource=true'])
     * ```
     */
    async exec(commandName, args) {
        let command = await this.find([commandName]);
        if (!command) {
            throw InvalidCommandException_1.InvalidCommandException.invoke(commandName, this.getSuggestions(commandName));
        }
        const commandInstance = this.application.container.make(command, [
            this.application,
            this,
        ]);
        return this.runCommand(commandInstance, [commandName].concat(args));
    }
    /**
     * Use manifest instance to lazy load commands
     */
    useManifest(manifest) {
        this.manifest = manifest;
        return this;
    }
    /**
     * Print the help screen for a given command or all commands/flags
     */
    printHelp(command) {
        if (command) {
            help_1.printHelpFor(command);
        }
        else {
            const flags = Object.keys(this.flags).map((name) => this.flags[name]);
            help_1.printHelp(this.getAllCommands(), flags);
        }
    }
}
exports.Kernel = Kernel;
