"use strict";
/*
 * @adonisjs/fold
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.IocProxyClass = exports.IoCProxyObject = void 0;
/**
 * Checks for the existence of fake on the target
 */
function hasFake(target) {
    return target.container.hasFake(target.binding);
}
/**
 * Calls the trap on the target
 */
function callTrap(target, trap, ...args) {
    if (hasFake(target)) {
        return Reflect[trap](target.container.useFake(target.binding, target.actual), ...args);
    }
    else {
        return Reflect[trap](target.actual, ...args);
    }
}
/**
 * Proxy handler to handle objects
 */
const objectHandler = {
    get(target, ...args) {
        return callTrap(target, 'get', ...args);
    },
    apply(target, ...args) {
        return callTrap(target, 'apply', ...args);
    },
    defineProperty(target, ...args) {
        return callTrap(target, 'defineProperty', ...args);
    },
    deleteProperty(target, ...args) {
        return callTrap(target, 'deleteProperty', ...args);
    },
    getOwnPropertyDescriptor(target, ...args) {
        return callTrap(target, 'getOwnPropertyDescriptor', ...args);
    },
    getPrototypeOf(target, ...args) {
        return callTrap(target, 'getPrototypeOf', ...args);
    },
    has(target, ...args) {
        return callTrap(target, 'has', ...args);
    },
    isExtensible(target, ...args) {
        return callTrap(target, 'isExtensible', ...args);
    },
    ownKeys(target, ...args) {
        return callTrap(target, 'ownKeys', ...args);
    },
    preventExtensions() {
        throw new Error('Cannot prevent extensions during a fake');
    },
    set(target, ...args) {
        return callTrap(target, 'set', ...args);
    },
    setPrototypeOf(target, ...args) {
        return callTrap(target, 'setPrototypeOf', ...args);
    },
};
/**
 * Proxy handler to handle classes and functions
 */
const classHandler = Object.assign({}, objectHandler, {
    construct(target, ...args) {
        return callTrap(target, 'construct', args);
    },
});
/**
 * Proxies the objects to fallback to fake, when it exists.
 */
class IoCProxyObject {
    constructor(binding, actual, container) {
        this.binding = binding;
        this.actual = actual;
        this.container = container;
        return new Proxy(this, objectHandler);
    }
}
exports.IoCProxyObject = IoCProxyObject;
/**
 * Proxies the class constructor to fallback to fake, when it exists.
 */
function IocProxyClass(binding, actual, container) {
    function Wrapped() { }
    Wrapped.binding = binding;
    Wrapped.actual = actual;
    Wrapped.container = container;
    return new Proxy(Wrapped, classHandler);
}
exports.IocProxyClass = IocProxyClass;
