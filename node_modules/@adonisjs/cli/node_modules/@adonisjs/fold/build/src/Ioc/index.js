"use strict";
/*
 * @adonisjs/fold
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ioc = void 0;
const path_1 = require("path");
const utils_1 = require("@poppinss/utils");
const Tracer_1 = __importDefault(require("./Tracer"));
const Injector_1 = require("./Injector");
const Resolver_1 = require("../Resolver");
const IoCProxy_1 = require("./IoCProxy");
const IocLookupException_1 = require("../Exceptions/IocLookupException");
const helpers_1 = require("../helpers");
/**
 * Ioc container to manage and compose dependencies of your application
 * with ease.
 *
 * The container follows and encourages the use of dependency injection
 * in your application and provides all the neccessary tools to make
 * DI simpler.
 */
class Ioc {
    constructor(emitEvents = false) {
        this.emitEvents = emitEvents;
        /**
         * For emitting emits
         */
        this.tracer = Tracer_1.default(this.emitEvents);
        /**
         * Autoloaded directories under a namespace
         */
        this.autoloads = {};
        /**
         * An array of autoloaded aliases, stored along side with
         * `autoloads` for a quick lookup on keys vs doing
         * `Object.keys` everytime
         */
        this.autoloadedAliases = [];
        /**
         * Autoloaded cache to improve the `require` speed, which is dog slow.
         */
        this.autoloadsCache = new Map();
        /**
         * Copy of aliases
         */
        this.aliases = {};
        /**
         * Copy of actual bindings
         */
        this.bindings = {};
        /**
         * Copy of fakes as a Map, since fakes are subjective to
         * mutations
         */
        this.fakes = new Map();
        /**
         * Using proxies or not? Fakes only works when below one
         * is set to true.
         */
        this.proxiesEnabled = false;
        /**
         * Injector is used for injecting dependencies to the class constructor
         * and the methods
         */
        this.injector = new Injector_1.Injector(this);
    }
    /**
     * Returns the binding return value. This method must be called when
     * [[hasBinding]] returns true.
     */
    resolveBinding(namespace) {
        const binding = this.bindings[namespace];
        if (!binding) {
            throw IocLookupException_1.IocLookupException.missingBinding(namespace);
        }
        this.tracer.in(namespace, !!binding.cachedValue);
        /**
         * Return the cached value for singletons or invoke callback
         */
        let value;
        if (binding.singleton && binding.cachedValue !== undefined) {
            value = binding.cachedValue; // use cachedValue
        }
        else if (binding.singleton) {
            value = binding.cachedValue = binding.callback(this); // invoke callback and cache
        }
        else {
            value = binding.callback(this); // invoke callback
        }
        this.tracer.out();
        return value;
    }
    /**
     * Load a file from the disk using Node.js require method. The output of
     * require is further cached to improve peformance.
     *
     * Make sure to call this method when [[isAutoloadNamespace]] returns true.
     */
    resolveAutoload(namespace) {
        const cacheEntry = this.autoloadsCache.get(namespace);
        this.tracer.in(namespace, !!cacheEntry);
        /**
         * Require the module and cache it to improve performance
         */
        if (cacheEntry) {
            this.tracer.out();
            return cacheEntry.cachedValue;
        }
        const baseNamespace = this.getAutoloadBaseNamespace(namespace);
        const diskPath = namespace.replace(baseNamespace, this.autoloads[baseNamespace]);
        const absPath = require.resolve(path_1.normalize(diskPath));
        this.autoloadsCache.set(namespace, { diskPath: absPath, cachedValue: require(absPath) });
        this.tracer.out();
        return this.autoloadsCache.get(namespace).cachedValue;
    }
    /**
     * Resolve the value for a namespace by trying all possible
     * combinations of `bindings`, `aliases`, `autoloading`
     * and finally falling back to `nodejs require`.
     */
    resolve(node) {
        switch (node.type) {
            case 'binding':
                return this.resolveBinding(node.namespace);
            case 'autoload':
                return this.resolveAutoload(node.namespace);
        }
    }
    /**
     * Resolves a namespace and injects it's dependencies to it
     */
    resolveAndMake(node, args) {
        switch (node.type) {
            case 'binding':
                return this.resolveBinding(node.namespace);
            case 'autoload':
                let value = this.resolveAutoload(node.namespace);
                /**
                 * We return an instance of default export for esm modules
                 */
                value = helpers_1.isEsm(value) && value.default ? value.default : value;
                return this.injector.injectDependencies(value, args || []);
        }
    }
    /**
     * Removes an autoload namespace from the cache. If the value doesn't
     * exists in the cache, then this method will be a noop.
     */
    removeAutoloadFromCache(namespace, removeRequire) {
        const item = this.autoloadsCache.get(namespace);
        if (!item) {
            return;
        }
        this.autoloadsCache.delete(namespace);
        if (removeRequire) {
            helpers_1.clearRequireCache(item.diskPath);
        }
    }
    /**
     * Wraps object and class to a proxy for enabling the fakes
     * API
     */
    wrapAsProxy(namespace, value) {
        /**
         * Wrap objects inside proxy
         */
        if (helpers_1.isObject(value)) {
            return new IoCProxy_1.IoCProxyObject(namespace, value, this);
        }
        /**
         * Wrap class inside proxy
         */
        if (helpers_1.isClass(value)) {
            return IoCProxy_1.IocProxyClass(namespace, value, this);
        }
        return value;
    }
    /**
     * Returns a boolean telling if value is a lookup node or not
     */
    isLookupNode(value) {
        return value && value.type && value.namespace;
    }
    /**
     * Instruct IoC container to use proxies when returning
     * bindings from `use` and `make` methods.
     */
    useProxies(enable = true) {
        this.proxiesEnabled = !!enable;
        return this;
    }
    bind(namespace, callback) {
        helpers_1.ensureIsFunction(callback, 'ioc.bind expect 2nd argument to be a function');
        this.tracer.emit('bind', { namespace, singleton: false });
        this.bindings[namespace] = { callback, singleton: false };
    }
    singleton(namespace, callback) {
        helpers_1.ensureIsFunction(callback, 'ioc.singleton expect 2nd argument to be a function');
        this.tracer.emit('bind', { namespace, singleton: true });
        this.bindings[namespace] = { callback, singleton: true };
    }
    alias(namespace, alias) {
        this.tracer.emit('alias', { alias, namespace });
        this.aliases[alias] = namespace;
    }
    /**
     * Define an alias for an existing directory and require
     * files without fighting with relative paths.
     *
     * Given the following directory structure
     *
     * ```sh
     * .app/
     * ├── controllers
     * │   └── foo.js
     * ├── services
     * │   └── foo.js
     * ├── models
     * │   └── foo.js
     * ```
     *
     * You are in file `controllers/foo.js`
     *
     * ### Without autoload
     * ```js
     * require('../services/foo')
     * require('../models/foo')
     * ```
     *
     * ### With outoload
     * ```
     * ioc.autoload(join(__dirname, 'app'), 'App')
     *
     * ioc.use('App/services/foo')
     * ioc.use('App/mdoels/foo')
     * ```
     */
    autoload(directoryPath, namespace) {
        this.tracer.emit('autoload', { directoryPath, namespace });
        /**
         * Store namespaces in an array for faster lookup
         * during resolve phase
         */
        this.autoloadedAliases.push(namespace);
        this.autoloads[namespace] = directoryPath;
    }
    /**
     * Clear the autoload cache for all the cached files or for a
     * single namespace.
     *
     * Optionally, you can remove it from `require` cache too.
     */
    clearAutoloadCache(namespace, clearModulesCache = false) {
        if (!namespace) {
            Array.from(this.autoloadsCache.keys()).forEach((key) => {
                this.removeAutoloadFromCache(key, clearModulesCache);
            });
            return;
        }
        this.removeAutoloadFromCache(namespace, clearModulesCache);
    }
    fake(namespace, callback) {
        helpers_1.ensureIsFunction(callback, 'ioc.fake expect 2nd argument to be a function');
        this.tracer.emit('fake', { namespace });
        this.fakes.set(namespace, { callback });
    }
    use(node) {
        /**
         * Get lookup node when node itself isn't a lookup node
         */
        const lookedupNode = typeof node === 'string' ? this.lookup(node) : node;
        /**
         * Do not proceed when unable to lookup Ioc container namespace
         */
        if (!lookedupNode || !lookedupNode.type) {
            throw IocLookupException_1.IocLookupException.lookupFailed(node);
        }
        /**
         * Attempt to resolve the module
         */
        let value = this.resolve(lookedupNode);
        /**
         * When not using proxies, then we must return the value untouched
         */
        if (!this.proxiesEnabled) {
            return value;
        }
        /**
         * Wrap and return `esm` module default exports to proxy
         */
        if (helpers_1.isEsm(value)) {
            if (value.default) {
                value = Object.assign({}, value, {
                    default: this.wrapAsProxy(lookedupNode.namespace, value.default),
                });
            }
            return value;
        }
        return this.wrapAsProxy(lookedupNode.namespace, value);
    }
    make(node, args) {
        /**
         * If value is not a namespace string and not a lookup node,
         * then we make the value as it is.
         *
         * Also we do not support fakes for raw values and hence there is
         * no point in wrapping it to a proxy
         */
        if (typeof node !== 'string' && !this.isLookupNode(node)) {
            return this.injector.injectDependencies(node, args || []);
        }
        /**
         * Get lookup node when node itself isn't a lookup node
         */
        const lookedupNode = typeof node === 'string' ? this.lookup(node) : node;
        /**
         * Do not proceed when unable to lookup Ioc container namespace
         */
        if (!lookedupNode || !lookedupNode.type) {
            throw IocLookupException_1.IocLookupException.lookupFailed(node);
        }
        /**
         * Attempt to make the lookedupNode.
         */
        const value = this.resolveAndMake(lookedupNode || node, args);
        /**
         * When not using proxies, then we must return the value untouched
         */
        if (!this.proxiesEnabled || helpers_1.isEsm(value)) {
            return value;
        }
        return this.wrapAsProxy(lookedupNode.namespace, value);
    }
    useFake(namespace, value) {
        const fake = this.fakes.get(namespace);
        if (!fake) {
            throw new utils_1.Exception(`Cannot find fake for "${namespace}"`);
        }
        fake.cachedValue = fake.cachedValue || fake.callback(this, value);
        return fake.cachedValue;
    }
    hasFake(namespace) {
        return this.fakes.has(namespace);
    }
    hasAlias(namespace) {
        return !!this.aliases[namespace];
    }
    hasBinding(namespace, checkAliases = false) {
        const binding = this.bindings[namespace];
        if (!binding && checkAliases) {
            return !!this.bindings[this.getAliasNamespace(namespace)];
        }
        return !!binding;
    }
    /**
     * Returns the complete namespace for a given alias. To avoid
     * `undefined` values, it is recommended to use `hasAlias`
     * before using this method.
     */
    getAliasNamespace(namespace) {
        return this.aliases[namespace];
    }
    /**
     * Returns a boolean telling if namespace is part of autoloads or not.
     * This method results may vary from the [[use]] method, since
     * the `use` method gives preference to the `bindings` first.
     *
     * ### NOTE:
     * Check the following example carefully.
     *
     * @example
     * ```js
     * // Define autoload namespace
     * ioc.autoload(join(__dirname, 'app'), 'App')
     *
     * ioc.bind('App/Services/Foo', () => {
     * })
     *
     * // return true
     * ioc.isAutoloadNamespace('App/Services/Foo')
     *
     * // Returns value from `bind` and not disk
     * ioc.use('App/Services/Foo')
     * ```
     */
    isAutoloadNamespace(namespace) {
        return !!this.getAutoloadBaseNamespace(namespace);
    }
    /**
     * Returns the base namespace for an autoloaded namespace.
     *
     * @example
     * ```js
     * ioc.autoload(join(__dirname, 'app'), 'App')
     *
     * ioc.getAutoloadBaseNamespace('App/Services/Foo') // returns App
     * ```
     */
    getAutoloadBaseNamespace(namespace) {
        return this.autoloadedAliases.find((alias) => namespace.startsWith(`${alias}/`));
    }
    restore(namespace) {
        this.fakes.delete(namespace);
    }
    /**
     * Execute a callback by resolving bindings from the container and only
     * executed when all bindings exists in the container.
     *
     * This is a clean way to use bindings, when you are not that user application
     * is using them or not.
     *
     * ```js
     * boot () {
     *  this.app.with(['Adonis/Src/Auth'], (Auth) => {
     *    Auth.extend('mongo', 'serializer', function () {
     *      return new MongoSerializer()
     *    })
     *  })
     * }
     * ```
     */
    with(namespaces, callback) {
        helpers_1.ensureIsFunction(callback, 'ioc.with expect 2nd argument to be a function');
        if (namespaces.every((namespace) => this.hasBinding(namespace, true))) {
            callback(...namespaces.map((namespace) => this.use(namespace)));
        }
    }
    /**
     * Call method on an object and inject dependencies to it automatically.
     */
    call(target, method, args) {
        if (typeof target[method] !== 'function') {
            throw new utils_1.Exception(`Missing method "${method}" on "${target.constructor.name}"`);
        }
        return this.injector.injectMethodDependencies(target, method, args || []);
    }
    /**
     * Lookup a namespace and return it's lookup node. The lookup node can speed
     * up resolving of namespaces via `use`, `useEsm` or `make` methods.
     */
    lookup(namespace, prefixNamespace) {
        /**
         * Ensure namespace is defined
         */
        if (!namespace) {
            throw new utils_1.Exception('Empty string cannot be used as IoC container reference', 500, 'E_INVALID_IOC_NAMESPACE');
        }
        /**
         * Build complete namespace
         */
        if (namespace.startsWith('/')) {
            namespace = namespace.substr(1);
        }
        else if (prefixNamespace) {
            namespace = `${prefixNamespace.replace(/\/$/, '')}/${namespace}`;
        }
        /**
         * Namespace is a binding
         */
        if (this.hasBinding(namespace)) {
            return {
                type: 'binding',
                namespace,
            };
        }
        /**
         * Resolving aliases as binding
         */
        if (this.hasAlias(namespace)) {
            return {
                type: 'binding',
                namespace: this.getAliasNamespace(namespace),
            };
        }
        /**
         * Namespace is part of pre-defined autoloads. We do not check
         * for the module existence
         */
        if (this.isAutoloadNamespace(namespace)) {
            return {
                type: 'autoload',
                namespace: namespace,
            };
        }
        return null;
    }
    /**
     * Returns the resolver instance to resolve Ioc container bindings with
     * little ease. Since, the IoCResolver uses an in-memory cache to
     * improve the lookup speed, we suggest keeping a reference to
     * the output of this method to leverage caching
     */
    getResolver(fallbackMethod, rcNamespaceKey, fallbackNamespace) {
        return new Resolver_1.IocResolver(this, fallbackMethod, rcNamespaceKey, fallbackNamespace);
    }
}
exports.Ioc = Ioc;
