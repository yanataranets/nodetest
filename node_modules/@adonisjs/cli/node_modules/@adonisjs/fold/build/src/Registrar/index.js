"use strict";
/*
 * @adonisjs/fold
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Registrar = void 0;
const utils_1 = require("@poppinss/utils");
/**
 * Registrar is used to register and boot the providers
 */
class Registrar {
    constructor(ioc, basePath) {
        this.ioc = ioc;
        this.basePath = basePath;
        /**
         * The first level of provider paths provided to the registrar
         */
        this.providersPaths = [];
        /**
         * An array of loaded providers. Their can be more providers than the
         * `_providersPaths` array, since each provider can provide it's
         * own sub providers
         */
        this.providers = [];
        /**
         * Whether or not the providers can be collected
         */
        this.collected = false;
    }
    /**
     * Load the provider by requiring the file from the disk
     * and instantiate it. If ioc container is using ES6
     * imports, then default exports are handled
     * automatically.
     */
    loadProvider(providerPath) {
        providerPath = this.basePath ? utils_1.resolveFrom(this.basePath, providerPath) : providerPath;
        const provider = utils_1.esmRequire(providerPath);
        if (typeof provider !== 'function') {
            throw new utils_1.Exception(`Make sure export default the provider from "${providerPath}"`);
        }
        return new provider(this.ioc);
    }
    /**
     * Loop's over an array of provider paths and pushes them to the
     * `providers` collection. This collection is later used to
     * register and boot providers
     */
    collect(providerPaths) {
        providerPaths.forEach((providerPath) => {
            const provider = this.loadProvider(providerPath);
            this.providers.push(provider);
            if (provider.provides) {
                this.collect(provider.provides);
            }
        });
    }
    /**
     * Register an array of provider paths
     */
    useProviders(providersPaths) {
        this.providersPaths = providersPaths;
        return this;
    }
    /**
     * Register all the providers by instantiating them and
     * calling the `register` method.
     *
     * The provider instance will be returned, which can be used
     * to boot them as well.
     */
    register() {
        if (this.collected) {
            return this.providers;
        }
        this.collected = true;
        this.collect(this.providersPaths);
        /**
         * Register collected providers
         */
        this.providers.forEach((provider) => {
            if (typeof provider.register === 'function') {
                provider.register();
            }
        });
        return this.providers;
    }
    /**
     * Boot all the providers by calling the `boot` method.
     * Boot methods are called in series.
     */
    async boot() {
        const providers = this.register();
        for (let provider of providers) {
            /* istanbul ignore else */
            if (typeof provider.boot === 'function') {
                await provider.boot();
            }
        }
    }
    /**
     * Register an boot providers together.
     */
    async registerAndBoot() {
        const providers = this.register();
        await this.boot();
        return providers;
    }
}
exports.Registrar = Registrar;
