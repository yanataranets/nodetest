"use strict";
/*
 * @adonisjs/sink
 *
 * (c) Harminder Virk <virk@adonisjs.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
*/
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@poppinss/utils");
const path_1 = require("path");
const logger_1 = require("./logger");
/**
 * Executes the instructions file of a given AdonisJs package. It will look for
 * `adonisjs.instructions` block inside the `package.json` file, otherwise
 * this method results in a noop.
 */
async function executeInstructions(packageName, projectRoot, application) {
    const sink = await Promise.resolve().then(() => __importStar(require('../index')));
    const packagePath = utils_1.resolveFrom(projectRoot, `${packageName}/package.json`);
    const pkg = require(packagePath);
    /**
     * Return early when there is no `adonisjs` block in package.json file
     */
    if (!pkg.adonisjs) {
        return true;
    }
    logger_1.logger.pauseLogger();
    /**
     * Execute instructions when they exists in the package.json file
     */
    if (pkg.adonisjs.instructions) {
        const normalizedPath = path_1.normalize(`${packageName}/${pkg.adonisjs.instructions}`);
        const instructionsPath = utils_1.resolveFrom(projectRoot, normalizedPath);
        /**
         * Requiring and executing instructions file
         */
        const instructions = utils_1.esmRequire(instructionsPath);
        await instructions(projectRoot, application, sink);
    }
    /**
     * Copy templates when defined in package.json file
     */
    if (pkg.adonisjs.templates) {
        const templatesRoot = path_1.join(path_1.dirname(packagePath), pkg.adonisjs.templates.basePath || './build/templates');
        sink.copyTemplates(projectRoot, application, templatesRoot, pkg.adonisjs.templates);
    }
    /**
     * Set env variables when defined in package.json file
     */
    if (pkg.adonisjs.env) {
        const env = new sink.EnvFile(projectRoot);
        Object.keys(pkg.adonisjs.env).forEach((key) => env.set(key, pkg.adonisjs.env[key]));
        env.commit();
        logger_1.logger.update('.env');
    }
    /**
     * Add package types to `tsconfig.json` file when they are defined
     */
    if (pkg.adonisjs.types) {
        const tsConfig = new sink.JsonFile(projectRoot, 'tsconfig.json');
        const types = tsConfig.get('compilerOptions.types') || [];
        if (!types.find((type) => type.includes(pkg.adonisjs.types))) {
            types.push(pkg.adonisjs.types);
            tsConfig.set('compilerOptions.types', types);
            tsConfig.commit();
            logger_1.logger.update('tsconfig.json');
        }
    }
    /**
     * Add commands to `.adonisrc.json` file
     */
    if (Array.isArray(pkg.adonisjs.commands)) {
        const adonisRcFile = new sink.RcFile(projectRoot);
        pkg.adonisjs.commands.forEach((command) => {
            adonisRcFile.addCommand(command);
        });
        adonisRcFile.commit();
        logger_1.logger.update('.adonisrc.json');
    }
    /**
     * Add providers to `.adonisrc.json` file
     */
    if (Array.isArray(pkg.adonisjs.providers)) {
        const adonisRcFile = new sink.RcFile(projectRoot);
        pkg.adonisjs.providers.forEach((provider) => {
            adonisRcFile.addProvider(provider);
        });
        adonisRcFile.commit();
        logger_1.logger.update('.adonisrc.json');
    }
    /**
     * Add ace providers to `.adonisrc.json` file
     */
    if (Array.isArray(pkg.adonisjs.aceProviders)) {
        const adonisRcFile = new sink.RcFile(projectRoot);
        pkg.adonisjs.aceProviders.forEach((provider) => {
            adonisRcFile.addAceProvider(provider);
        });
        adonisRcFile.commit();
        logger_1.logger.update('.adonisrc.json');
    }
    /**
     * Render markdown file when `instructionsMd` property is defined in
     * package.json file
     */
    if (pkg.adonisjs.instructionsMd) {
        await sink.renderMarkdown(path_1.join(path_1.dirname(packagePath), pkg.adonisjs.instructionsMd), packageName);
    }
    /**
     * Filtering duplicate messages before logging them
     */
    const processedMessages = new Set();
    logger_1.logger.resumeLogger((message) => {
        if (processedMessages.has(message.message)) {
            return false;
        }
        processedMessages.add(message.message);
        return true;
    });
    return true;
}
exports.executeInstructions = executeInstructions;
