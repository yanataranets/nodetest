"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const os_1 = require("os");
const chokidar_1 = __importDefault(require("chokidar"));
const nanomatch_1 = __importDefault(require("nanomatch"));
const events_1 = require("events");
const fs_extra_1 = require("fs-extra");
const path_1 = require("path");
const debug = debug_1.default('adonis:tsc');
const isWindows = os_1.platform() === 'win32';
debug('is windows %s', isWindows);
const backslashReg = /\\/g;
function normalizeSlashes(path) {
    if (!isWindows) {
        return path;
    }
    return path.replace(backslashReg, '/');
}
class TypescriptCompiler extends events_1.EventEmitter {
    constructor(ts, _configPath, _cwd) {
        super();
        this.ts = ts;
        this._configPath = _configPath;
        this._cwd = _cwd;
        this._sourceFiles = {};
        this._includePatterns = [];
        this._excludePatterns = [];
        this._transformers = {
            before: [],
            after: [],
        };
        this._plugins = [];
        this._ignoredSourceFiles = new Set();
        if (!path_1.isAbsolute(this._configPath)) {
            this._configPath = path_1.join(this._cwd, this._configPath);
        }
        debug('config path %s', this._configPath);
    }
    _buildProject(fileNames, options) {
        this._plugins.forEach(({ fn, lifecycle }) => {
            if (lifecycle === 'after') {
                this._transformers.after.push(fn(this.ts, options));
            }
            else {
                this._transformers.before.push(fn(this.ts, options));
            }
        });
        this.host = this.ts.createCompilerHost(options);
        const program = this.ts.createProgram(fileNames, options, this.host);
        const result = program.emit(undefined, this.ts.sys.writeFile, undefined, undefined, this._transformers);
        const diagnostics = this.ts.getPreEmitDiagnostics(program).concat(result.diagnostics);
        this.emit('initial:build', result.emitSkipped, diagnostics);
        return !result.emitSkipped;
    }
    _loadConfig(optionsToExtends) {
        let hardException = null;
        const parsedConfig = this.ts.getParsedCommandLineOfConfigFile(this._configPath, optionsToExtends || {}, Object.assign(Object.assign({}, this.ts.sys), { useCaseSensitiveFileNames: true, onUnRecoverableConfigFileDiagnostic: (error) => {
                hardException = error;
            } }));
        if (hardException) {
            return { error: hardException };
        }
        const includeSpecs = parsedConfig['configFileSpecs'].validatedIncludeSpecs || [];
        this._includePatterns = includeSpecs.map((path) => {
            return normalizeSlashes(path_1.join(this._cwd, path));
        });
        debug('include patterns %O', this._includePatterns);
        const excludeSpecs = parsedConfig['configFileSpecs'].validatedExcludeSpecs || [];
        this._excludePatterns = excludeSpecs.map((path) => {
            return normalizeSlashes(path_1.join(this._cwd, path));
        });
        debug('exclude patterns %O', this._excludePatterns);
        parsedConfig.fileNames.forEach((file) => {
            this._sourceFiles[path_1.normalize(file)] = { version: 1 };
        });
        debug('initial source files %O', this._sourceFiles);
        return { config: parsedConfig };
    }
    _getServiceHost(options) {
        return {
            getScriptFileNames: () => Object.keys(this._sourceFiles),
            getScriptVersion: file => {
                return this._sourceFiles[file] && this._sourceFiles[file].version.toString();
            },
            getScriptSnapshot: fileName => {
                const contents = this.ts.sys.readFile(fileName);
                if (contents === undefined) {
                    return undefined;
                }
                return this.ts.ScriptSnapshot.fromString(contents.toString());
            },
            getCustomTransformers: () => this._transformers,
            getCurrentDirectory: () => this._cwd,
            getCompilationSettings: () => options,
            getDefaultLibFileName: options => this.ts.getDefaultLibFilePath(options),
            fileExists: this.ts.sys.fileExists,
            readFile: this.ts.sys.readFile,
            readDirectory: this.ts.sys.readDirectory,
        };
    }
    _createLanguageService(options) {
        this._languageService = this.ts.createLanguageService(this._getServiceHost(options), this.ts.createDocumentRegistry());
    }
    _isTsFile(filePath) {
        return filePath.endsWith('.ts');
    }
    _isIncludedInProjectFiles(absPath) {
        if (this._ignoredSourceFiles.has(absPath)) {
            return false;
        }
        const unixPath = normalizeSlashes(absPath);
        debug('nanomatch unix path %s', unixPath);
        if (!nanomatch_1.default.isMatch(unixPath, this._includePatterns)) {
            debug('file %s not under included pattern', absPath);
            this._ignoredSourceFiles.add(absPath);
            return false;
        }
        const excluded = nanomatch_1.default.isMatch(unixPath, this._excludePatterns);
        if (excluded) {
            debug('file %s under excluded pattern', absPath);
            this._ignoredSourceFiles.add(absPath);
            return false;
        }
        return true;
    }
    _isTsSourceFile(absPath) {
        if (this._sourceFiles[absPath]) {
            return true;
        }
        return this._isIncludedInProjectFiles(absPath);
    }
    _getFileErrors(absPath) {
        return this._languageService
            .getCompilerOptionsDiagnostics()
            .concat(this._languageService.getSyntacticDiagnostics(absPath))
            .concat(this._languageService.getSemanticDiagnostics(absPath));
    }
    async _processSourceFile(absPath, relativePath) {
        const output = this._languageService.getEmitOutput(absPath);
        if (output.emitSkipped) {
            this.emit('subsequent:build', relativePath, true, this._getFileErrors(absPath));
            return;
        }
        await Promise.all(output.outputFiles.map((one) => {
            return fs_extra_1.outputFile(one.name, one.text, 'utf-8');
        }));
        this.emit('subsequent:build', relativePath, false, this._getFileErrors(absPath));
    }
    _onChange(filePath) {
        debug('event:change %s', filePath);
        if (!this._isTsFile(filePath)) {
            this.emit('change', filePath);
            return;
        }
        const absPath = path_1.join(this._cwd, filePath);
        if (!this._isTsSourceFile(absPath)) {
            return;
        }
        this._sourceFiles[absPath].version++;
        this._processSourceFile(absPath, filePath);
    }
    _onRemove(filePath) {
        debug('event:remove %s', filePath);
        if (!this._isTsFile(filePath)) {
            this.emit('unlink', filePath);
            return;
        }
        const absPath = path_1.join(this._cwd, filePath);
        delete this._sourceFiles[absPath];
        this.emit('source:unlink', filePath);
    }
    _onNewFile(filePath) {
        debug('event:remove %s', filePath);
        if (!this._isTsFile(filePath)) {
            this.emit('add', filePath);
            return;
        }
        const absPath = path_1.join(this._cwd, filePath);
        if (!this._isTsSourceFile(absPath)) {
            return;
        }
        this._sourceFiles[absPath] = { version: 1 };
        this._processSourceFile(absPath, filePath);
    }
    on(event, cb) {
        super.on(event, cb);
        return this;
    }
    use(transformer, lifecycle) {
        this._plugins.push({ fn: transformer, lifecycle });
        return this;
    }
    build(parsedConfig) {
        return this._buildProject(parsedConfig.fileNames, parsedConfig.options);
    }
    parseConfig(compileOptionsToExtend) {
        return this._loadConfig(compileOptionsToExtend);
    }
    watch(parsedConfig, watchPattern = ['.'], options) {
        const success = this._buildProject(parsedConfig.fileNames, parsedConfig.options);
        if (!success) {
            return;
        }
        options = Object.assign({
            ignored: [
                'node_modules/**',
                `${parsedConfig.options.outDir}/**`,
                /(^|[\/\\])\../,
            ],
            cwd: this._cwd,
            ignoreInitial: true,
        }, options);
        this.watcher = chokidar_1.default.watch(watchPattern, options);
        this.watcher.on('ready', () => {
            debug('watcher ready');
            this.emit('watcher:ready');
            this._createLanguageService(parsedConfig.options);
        });
        this.watcher.on('add', (path) => this._onNewFile(path));
        this.watcher.on('change', (path) => this._onChange(path));
        this.watcher.on('unlink', (path) => this._onRemove(path));
    }
}
exports.TypescriptCompiler = TypescriptCompiler;
